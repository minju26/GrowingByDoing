# KnapSack Problem (배낭 문제)
> - 대표적인 **Dynamic Programming** 문제   
> - 최대 **M**kg까지 담을 수 있는 배낭, 무게가 **N**kg 이고 가치가 **K**인 물건들   
> - 배낭에 물건들의 가치 합이 최대가 되도록 배낭 채우기

## 배낭 알고리즘이 DP인 이유
무게가 x이고, 가치가 v인 물건을 배낭에 담으면,   
배낭 속 물건의 현재 가치 합이 v가 되고 남은 무게가 (M-x)kg이 되며   
최대 **(M-x)kg까지 담을 수 있는 배낭**을 채우는 문제가 됨.

## 물건담기
0. 전체 물건들을 처음부터 차례로 담을지 말지를 결정한다.   
i번째 물건, 물건의 무게 x, 물건의 가치 v, 현재 배낭의 남은 무게 m   
dp[i][m]: 남은 배낭의 무게가 m이고 i번째 물건이 담긴 상황이며 기존의 최대 가치

1. 물건의 무게 > 배낭이 담을 수 있는 최대 무게
    - 물건을 담을 수 없으므로, (i-1)번째 물건을 담았을 때의 상태가 유지됨
    - dp[i][m] = dp[i-1][m]

2. 물건의 무게 <= 배낭이 담을 수 있는 최대 무게  
    1) 넣지 않는다   
        - dp[i][m] = dp[i-1][m]
    2) 넣는다   
        - i번째 물건을 넣었다고 가정한다면, (m-x)kg 배낭을 채우는 문제로 치환된다.   
        dp[i][m] = v + dp[i-1][m-x]   
    3) 따라서 max(dp[i-1][m], v + dp[i-1][m-x])로, 가치 합이 최대가 되는 것을 선택한다.

## 표로 알아보기
> 조건 : 최대 배낭 무게 7kg, 4개의 물건(무게, 가치)

||(6,13)|(4,8)|(3,6)|(5,12)
|:--:|:--:|:--:|:--:|:--:|
|0|0|0|0|0|
|1|0|0|0|0|
|2|0|0|0|0|
|3|0|0|6|6|
|4|0|8|8|8|
|5|0|8|8|12|
|6|13|13|13|13|
|7|13|13|14|14|

따라서 dp[7][7] = 14로 최대 가치는 14인것을 알 수 있다.


