# Graph (그래프)
- Vertex(정점)과 Edge(간선)로 이루어진 자료구조
- 물리적 연결관계 뿐 아니라 추상적 관련성도 표현
- Directd Graph: 간선에 방향이 있는 그래프
- Undirected Graph: 간선에 방향이 없는 그래프

## Adjacency Matrix (인접 행렬)
그래프의 연결 관계를 행렬로 표현한 이차원 배열   
adj[i][j] : i노드에서 j노드로 가는 간선이 존재하는 경우 1 (아니면 0)   
Undirected 그래프인 경우, i노드에서 j노드로 가는 간선이 존재한다면 j노드에서 i노드로 가는 간선또한 존재한다.   
(인접 행렬로 구현하는 경우, 대각 성분을 기준으로 대칭인 성질을 가진다.)

>장점
>1. 구현이 쉽다.
>2. 두 노드가 연결되어 있는지 확인할 때, indexing으로 접근하여 O(1)의 시간복잡도를 가진다.   
>3. 간선 추가와 제거가 빠르다. O(1)의 시간복잡도를 가진다.

>단점
>1. 어떤 노드(i)에 연결된 모든 노드를 방문하고 싶은 경우, adj[i][1]부터 adj[1][v]를 모두 확인해야하기 때문에 O(v)의 시간이 걸린다.
>2. 노드 수에 비해 간선의 수가 훨씬 적다면 공간이 낭비된다. (Dense Graph에 적합)
>3. 노드 추가와 제거가 오래걸린다. O(v^2)의 시간복잡도를 가진다.


## Adjacency List (인접 리스트)
그래프에서 각각의 노드에 연결된 노드를 원소로 가지는 리스트의 배열   
adj[i] : i노드에 연결된 노드를 원소로 가지는 리스트   
Undirected 그래프인 경우, i노드에서 j노드로 가는 간선이 존재한다면 adj[i]가 j를 원소로 가지고, adj[j]도 i를 원소로 갖는다.   
Python에서는 노드가 key, 인접한 노드가 value가 되는 딕셔너리로 구현할 수 있다.

>장점
>1. 모든 원소의 개수의 합이 간선의 개수와 동일하다.(실제 연결된 노드 정보만 저장하기 때문)
>2. 간선의 개수에 비례하는 메모리만 차지하기 때문에 메모리 효율이 좋다.
>3. 특정 노드에 연결된 모든 노드를 방문해야 하는 경우, 시간상 이점을 가진다.
>4. 노드의 추가와 제거가 빠르다.
>5. 간선 추가가 빠르다. O(1)의 시간복잡도를 가진다.

>단점
>1. 두 노드(i, j)의 연결 여부를 확인할 때, adj[i] 리스트를 순회하여 j가 있는지 확인해야 하므로, O(v)의 시간복잡도를 가진다.   
(인접 행렬의 경우 adj[i]만 1인지 확인, O(1)의 시간복잡도를 가진다.)
